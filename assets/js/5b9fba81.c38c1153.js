"use strict";(globalThis.webpackChunkamigo_docs=globalThis.webpackChunkamigo_docs||[]).push([[265],{2998:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>t,default:()=>m,frontMatter:()=>a,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"manual/define-problem/models","title":"Models","description":"The Model class is responsible for assembling individual components into a complete optimization problem. It manages component instantiation, variable linking, code generation, and compilation.","source":"@site/docs/manual/define-problem/models.md","sourceDirName":"manual/define-problem","slug":"/manual/define-problem/models","permalink":"/amigo/docs/manual/define-problem/models","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Objectives","permalink":"/amigo/docs/manual/define-problem/objectives"},"next":{"title":"Solve a problem","permalink":"/amigo/docs/manual/solve-problem"}}');var s=i(4848),l=i(8453);const a={sidebar_position:5},t="Models",d={},c=[{value:"Creating a Model",id:"creating-a-model",level:2},{value:"Adding Components",id:"adding-components",level:2},{value:"Single Instance",id:"single-instance",level:3},{value:"Multiple Instances",id:"multiple-instances",level:3},{value:"Variable Linking",id:"variable-linking",level:2},{value:"Basic Linking",id:"basic-linking",level:3},{value:"Array Linking",id:"array-linking",level:3},{value:"Linking Across Instances",id:"linking-across-instances",level:3},{value:"Linking Rules",id:"linking-rules",level:3},{value:"Build and Initialize",id:"build-and-initialize",level:2},{value:"The Build Process",id:"the-build-process",level:3},{value:"Complete Example",id:"complete-example",level:2},{value:"Sub-Models",id:"sub-models",level:2}];function r(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"models",children:"Models"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Model"})," class is responsible for assembling individual components into a complete optimization problem. It manages component instantiation, variable linking, code generation, and compilation."]}),"\n",(0,s.jsx)(n.h2,{id:"creating-a-model",children:"Creating a Model"}),"\n",(0,s.jsx)(n.p,{children:"A model is created with a unique name that will be used for generated C++ files:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import amigo as am\n\nmodel = am.Model("my_optimization")\n'})}),"\n",(0,s.jsx)(n.p,{children:"The model name should be a valid Python identifier (no spaces or special characters)."}),"\n",(0,s.jsx)(n.h2,{id:"adding-components",children:"Adding Components"}),"\n",(0,s.jsxs)(n.p,{children:["Components are added to the model using ",(0,s.jsx)(n.code,{children:"add_component"}),", which takes three arguments:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"add_component(name, num_instances, component_object)\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"name"}),": Unique identifier for this component group"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"num_instances"}),": Number of instances to create"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"component_object"}),": Instance of your Component class"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"single-instance",children:"Single Instance"}),"\n",(0,s.jsx)(n.p,{children:"For static analysis or single-point optimization:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'rosenbrock = Rosenbrock()\nmodel.add_component("opt", 1, rosenbrock)\n'})}),"\n",(0,s.jsx)(n.h3,{id:"multiple-instances",children:"Multiple Instances"}),"\n",(0,s.jsx)(n.p,{children:"For time-dependent problems, repeated structures, or spatial discretization:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# Optimal control with 100 time steps\ndynamics = DynamicsComponent()\nmodel.add_component("dynamics", 100, dynamics)\n\n# This creates 100 copies of the component\n'})}),"\n",(0,s.jsx)(n.p,{children:"Each instance maintains its own variables, indexed from 0 to num_instances-1."}),"\n",(0,s.jsx)(n.h2,{id:"variable-linking",children:"Variable Linking"}),"\n",(0,s.jsxs)(n.p,{children:["Linking establishes relationships between variables across components. The linking syntax uses scoped names: ",(0,s.jsx)(n.code,{children:"component_name.variable_name[indices]"})]}),"\n",(0,s.jsx)(n.h3,{id:"basic-linking",children:"Basic Linking"}),"\n",(0,s.jsx)(n.p,{children:"Link scalar variables:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# Output of comp1 becomes input to comp2\nmodel.link("comp1.output", "comp2.input")\n'})}),"\n",(0,s.jsx)(n.h3,{id:"array-linking",children:"Array Linking"}),"\n",(0,s.jsx)(n.p,{children:"Link array elements or slices:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# Link entire array\nmodel.link("comp1.forces[:3]", "comp2.loads[:3]")\n\n# Link specific elements\nmodel.link("comp1.stress[0]", "comp2.load")\n\n# Link with different indices\nmodel.link("comp1.state[0:3]", "comp2.input[1:4]")\n'})}),"\n",(0,s.jsx)(n.h3,{id:"linking-across-instances",children:"Linking Across Instances"}),"\n",(0,s.jsx)(n.p,{children:"For time-marching or sequential processes:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'num_steps = 50\n\n# Link state at time k+1 to previous state at time k\nfor k in range(num_steps):\n    model.link(f"dynamics.q[{k+1}, :]", f"dynamics.q_prev[{k}, :]")\n'})}),"\n",(0,s.jsx)(n.h3,{id:"linking-rules",children:"Linking Rules"}),"\n",(0,s.jsxs)(n.p,{children:["Variables are linked between components through an explicit linking process. Indices within the model are linked with text-based linking arguments. The names provided to the linking command are scoped by ",(0,s.jsx)(n.code,{children:"component_name.variable_name"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Inputs to Inputs"}),": Linking establishes that two inputs from different components are the same variable (shared)"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'model.link("comp1.x", "comp2.x")\n# comp1.x and comp2.x are now the same variable\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Outputs to Outputs"}),": Linking two outputs together means the sum of the two output values"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'model.link("comp1.force", "comp2.force")\n# The sum: comp1.force + comp2.force\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Constraints to Constraints"}),": Linking two constraints together means the sum of the constraint values"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'model.link("comp1.residual", "comp2.residual")\n# The sum: comp1.residual + comp2.residual\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsx)(n.p,{children:"You cannot link between different variable types. For instance, you cannot link inputs to constraints or outputs to objectives."})}),"\n",(0,s.jsx)(n.h2,{id:"build-and-initialize",children:"Build and Initialize"}),"\n",(0,s.jsx)(n.p,{children:"After adding all components and links, compile and initialize:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# Generate and compile C++ code with automatic differentiation\nmodel.build_module()\n\n# Initialize the model (allocate memory, set initial values)\nmodel.initialize()\n"})}),"\n",(0,s.jsx)(n.h3,{id:"the-build-process",children:"The Build Process"}),"\n",(0,s.jsxs)(n.p,{children:["When ",(0,s.jsx)(n.code,{children:"build_module()"})," is called:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Python code in ",(0,s.jsx)(n.code,{children:"compute()"})," methods is analyzed"]}),"\n",(0,s.jsx)(n.li,{children:"Optimized C++ code is generated"}),"\n",(0,s.jsx)(n.li,{children:"Automatic differentiation (A2D) is incorporated"}),"\n",(0,s.jsx)(n.li,{children:"Code is compiled to a Python extension module"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Generated files:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"{model_name}.cpp"})," - C++ source"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"{model_name}.h"})," - Header file"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"{model_name}.pyd/.so"})," - Compiled binary"]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsxs)(n.p,{children:["Whenever you modify ",(0,s.jsx)(n.code,{children:"compute()"})," methods, you must call ",(0,s.jsx)(n.code,{children:"build_module()"})," again to recompile."]})}),"\n",(0,s.jsx)(n.h2,{id:"complete-example",children:"Complete Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import amigo as am\n\n# Define components\nclass Source(am.Component):\n    def __init__(self):\n        super().__init__()\n        self.add_input("x", value=1.0, lower=0.0, upper=10.0)\n        self.add_output("y")\n    \n    def compute(self):\n        self.outputs["y"] = self.inputs["x"]**2\n\nclass Processor(am.Component):\n    def __init__(self):\n        super().__init__()\n        self.add_input("z")\n        self.add_output("w")\n        self.add_objective("cost")\n    \n    def compute(self):\n        z = self.inputs["z"]\n        self.outputs["w"] = am.sqrt(z)\n        self.objective["cost"] = z\n\n# Build model\nmodel = am.Model("pipeline")\n\n# Add components\nmodel.add_component("source", 1, Source())\nmodel.add_component("proc", 3, Processor())\n\n# Link components\nmodel.link("source.y", "proc.z[0]")\nfor i in range(2):\n    model.link(f"proc.w[{i}]", f"proc.z[{i+1}]")\n\n# Build and initialize\nmodel.build_module()\nmodel.initialize()\n\n# Now ready for optimization\nopt = am.Optimizer(model)\nopt.optimize()\n'})}),"\n",(0,s.jsx)(n.h2,{id:"sub-models",children:"Sub-Models"}),"\n",(0,s.jsxs)(n.p,{children:["You can add sub-models to a model by calling ",(0,s.jsx)(n.code,{children:'model.add_sub_model("sub_model", sub_model)'}),". In this case, the scope becomes ",(0,s.jsx)(n.code,{children:"sub_model.component_name.variable_name"}),". Any links specified in the sub-model are automatically added to the main model."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# Create sub-model for wing analysis\nwing = am.Model("wing")\nwing.add_component("aero", 1, AeroComponent())\nwing.add_component("structure", 1, StructureComponent())\nwing.link("aero.pressure", "structure.loads")\n\n# Create main aircraft model\naircraft = am.Model("aircraft")\naircraft.add_sub_model("left_wing", wing)\naircraft.add_sub_model("right_wing", wing)\n\n# Link between sub-models\naircraft.link("left_wing.structure.weight", "total_weight")\naircraft.link("right_wing.structure.weight", "total_weight")\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Variable paths in sub-models use the format: ",(0,s.jsx)(n.code,{children:"sub_model_name.component_name.variable_name"})]})]})}function m(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(r,{...e})}):r(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>t});var o=i(6540);const s={},l=o.createContext(s);function a(e){const n=o.useContext(l);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),o.createElement(l.Provider,{value:n},e.children)}}}]);